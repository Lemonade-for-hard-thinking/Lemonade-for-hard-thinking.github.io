<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>编译原理实验二：正则表达式转换为DFA图 | 尼古拉斯.铁柱</title><meta name="author" content="铁柱帅哥"><meta name="copyright" content="铁柱帅哥"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="实验内容 设计一个应用软件，以实现将正则表达式转换为有限自动机的过程，包括以下步骤： ​ 正则表达式---&gt; NFA ---&gt; DFA---&gt; DFA最小化---&gt;词法分析程序（选做内容） 必做实验内容及要求  正则表达式应该支持命名操作，支持的运算符包括：  转义符号 (\) 连接 选择 (|) 闭包 (*) 正闭包 (+) 字符集 ([])">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理实验二：正则表达式转换为DFA图">
<meta property="og:url" content="https://lemonade-for-hard-thinking.github.io/2024/10/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%BA%8C/index.html">
<meta property="og:site_name" content="尼古拉斯.铁柱">
<meta property="og:description" content="实验内容 设计一个应用软件，以实现将正则表达式转换为有限自动机的过程，包括以下步骤： ​ 正则表达式---&gt; NFA ---&gt; DFA---&gt; DFA最小化---&gt;词法分析程序（选做内容） 必做实验内容及要求  正则表达式应该支持命名操作，支持的运算符包括：  转义符号 (\) 连接 选择 (|) 闭包 (*) 正闭包 (+) 字符集 ([])">
<meta property="og:locale">
<meta property="og:image" content="https://lemonade-for-hard-thinking.github.io/img/background.jpg">
<meta property="article:published_time" content="2024-10-19T11:36:38.000Z">
<meta property="article:modified_time" content="2024-10-22T10:11:37.504Z">
<meta property="article:author" content="铁柱帅哥">
<meta property="article:tag" content="尼古拉斯.铁柱">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lemonade-for-hard-thinking.github.io/img/background.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://lemonade-for-hard-thinking.github.io/2024/10/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%BA%8C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":false,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '编译原理实验二：正则表达式转换为DFA图',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-22 18:11:37'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 7 || hour >= 19
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="尼古拉斯.铁柱"><img class="site-icon" src="/img/avatar.jpg"/><span class="site-name">尼古拉斯.铁柱</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">编译原理实验二：正则表达式转换为DFA图</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-10-19T11:36:38.000Z" title="Created 2024-10-19 19:36:38">2024-10-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-10-22T10:11:37.504Z" title="Updated 2024-10-22 18:11:37">2024-10-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="编译原理实验二：正则表达式转换为DFA图"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="实验内容">实验内容</h2>
<p>设计一个应用软件，以实现将正则表达式转换为有限自动机的过程，包括以下步骤：</p>
<p>​ 正则表达式---&gt; NFA ---&gt; DFA---&gt;
DFA最小化---&gt;词法分析程序（选做内容）</p>
<p><strong>必做实验内容及要求</strong></p>
<ol type="1">
<li>正则表达式应该支持命名操作，支持的运算符包括：
<ul>
<li>转义符号 (<code>\</code>)</li>
<li>连接</li>
<li>选择 (<code>|</code>)</li>
<li>闭包 (<code>*</code>)</li>
<li>正闭包 (<code>+</code>)</li>
<li>字符集 (<code>[]</code>)</li>
<li>可选 (<code>?</code>)</li>
<li>括号 (<code>()</code>)</li>
</ul></li>
<li>提供一个源程序编辑界面，允许用户输入一行或多行正则表达式，并支持保存和打开正则表达式文件。</li>
<li>提供窗口以查看转换得到的 NFA（以状态转换表的形式呈现）。</li>
<li>提供窗口以查看转换得到的 DFA（以状态转换表的形式呈现）。</li>
<li>提供窗口以查看转换得到的最小化 DFA（以状态转换表的形式呈现）。</li>
<li>应用程序需为 Windows 界面。</li>
<li>书写完善的软件文档。</li>
</ol>
<p><strong>选做实验内容及要求</strong></p>
<ul>
<li>将最小化得到的 DFA 图转换为词法分析源程序。
<ul>
<li>该分析程序需使用 C/C++
语言描述，只能采用讲稿中的转换方法一或转换方法二生成源程序。</li>
<li>系统需提供窗口以查看转换得到的词法分析源程序。</li>
<li>注意事项：如果选做该内容，实验文档和使用说明书中需包含相关设计文档及操作说明。</li>
</ul></li>
</ul>
<p><strong>实验实现的编程语言</strong></p>
<ul>
<li><strong>C++ 程序设计语言</strong></li>
</ul>
<p><strong>测试样例</strong></p>
<ul>
<li><code>digit = [0-9]</code></li>
<li><code>letter = [A-Za-z]</code></li>
<li><code>_num100 = (\+|-)?digit+</code></li>
<li><code>_ID101 = letter(letter|digit)*</code></li>
<li><code>_specail200S = \+ | - | \* | / | = | &lt; | &lt;= | &lt;&lt;</code></li>
</ul>
<p><strong>说明</strong></p>
<ol type="1">
<li><p>使用命名时加下划线 (<code>_</code>) 表示该正则表达式需要生成 DFA
图。</p></li>
<li><p>名称中的数字为对应单词的编码。</p></li>
<li><p>名称中的数字后加 <code>S</code>
表示后面有多个单词，对应单词的编码从这个数值开始递增。</p></li>
<li><p>整数中的正号 (<code>+</code>)
在系统中已被用作正闭包运算符，因此需要引入转义符号 <code>\</code>
进行区分。</p></li>
</ol>
<h2 id="实验步骤及代码">实验步骤及代码</h2>
<h3 id="实验所使用的类和函数的声明">实验所使用的类和函数的声明</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QStack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;qqueue.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> QMap&lt;QString, <span class="type">int</span>&gt;TokenID;</span><br><span class="line"><span class="type">static</span> QHash&lt;QString, QString&gt;Definitions;<span class="comment">//命名定义</span></span><br><span class="line"><span class="type">static</span> QMap&lt;QString, QVector&lt;QChar&gt;&gt; Definitions_char;<span class="comment">//命名里面包含的字符，输出代码使用，后面加的</span></span><br><span class="line"><span class="type">static</span> QMap&lt;QChar, <span class="type">int</span>&gt;Isp = &#123; &#123;<span class="string">&#x27;#&#x27;</span>,<span class="number">0</span>&#125;, &#123;<span class="string">&#x27;(&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;*&#x27;</span>,<span class="number">7</span>&#125;,&#123;<span class="string">&#x27;+&#x27;</span>,<span class="number">5</span>&#125;,&#123;<span class="string">&#x27;|&#x27;</span>,<span class="number">3</span>&#125;,&#123;<span class="string">&#x27;)&#x27;</span>,<span class="number">8</span>&#125; &#125;;<span class="comment">//栈内优先度</span></span><br><span class="line"><span class="type">static</span> QMap&lt;QChar, <span class="type">int</span>&gt;Icp = &#123; &#123;<span class="string">&#x27;#&#x27;</span>,<span class="number">0</span>&#125;, &#123;<span class="string">&#x27;(&#x27;</span>,<span class="number">8</span>&#125;,&#123;<span class="string">&#x27;*&#x27;</span>,<span class="number">6</span>&#125;,&#123;<span class="string">&#x27;+&#x27;</span>,<span class="number">4</span>&#125;,&#123;<span class="string">&#x27;|&#x27;</span>,<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;)&#x27;</span>,<span class="number">1</span>&#125; &#125;;<span class="comment">//栈外优先度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">	QString Reg_Exp;<span class="comment">//正则表达式</span></span><br><span class="line">	<span class="comment">//QString Reg_Exp_Name;//正则表达式的名字</span></span><br><span class="line">	QMap&lt;<span class="type">int</span>, QMap&lt;<span class="type">int</span>, QString&gt;&gt;G;<span class="comment">//NFA图的存贮结构</span></span><br><span class="line">	<span class="type">int</span> Points_num = <span class="number">0</span>;<span class="comment">//图像点的数量</span></span><br><span class="line">	<span class="type">int</span> Begin_Point = <span class="number">0</span>, End_Point = <span class="number">0</span>;<span class="comment">//图像的起点和终点，NFA的起点和终点只有一个</span></span><br><span class="line"></span><br><span class="line">	QVector&lt;QString&gt;Char_set;<span class="comment">//正则表达式的字符集合，后面加的,在NFA转DFA的时候用的</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//运算的函数</span></span><br><span class="line">	QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;Char_Graph(QString tempchar);<span class="comment">//为单个字符创建图像</span></span><br><span class="line">	QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title function_">And_Operation</span><span class="params">(QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;n1, QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;n2)</span>;<span class="comment">//并置运算</span></span><br><span class="line">	QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title function_">Or_Operation</span><span class="params">(QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;n1, QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;n2)</span>;<span class="comment">//在“各种中选择”运算</span></span><br><span class="line">	QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title function_">Repeat_Operation</span><span class="params">(QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;n1)</span>;<span class="comment">//重复运算</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> <span class="title function_">GenerateNFA</span><span class="params">()</span>;<span class="comment">//根据预处理之后的正则表达式生成NFA</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//NFA转DFA的相关</span></span><br><span class="line">	<span class="type">int</span> DFA_Points_num = <span class="number">0</span>;<span class="comment">//</span></span><br><span class="line">	<span class="type">int</span> DFA_Begin_Point = <span class="number">0</span>;</span><br><span class="line">	QVector&lt;<span class="type">int</span>&gt;DFA_End_Point;<span class="comment">//DFA的结束点</span></span><br><span class="line">	QMap&lt;<span class="type">int</span>, QSet&lt;<span class="type">int</span>&gt;&gt;DFA_point;<span class="comment">//DFA中的点对应的NFA中的点集合，</span></span><br><span class="line">	QMap&lt;<span class="type">int</span>, QSet&lt;<span class="type">int</span>&gt;&gt; Point_Epsilon_Closure;<span class="comment">//NFA的各个点的epilon闭包，用函数Epsilon_Closure()求，后面添加的。</span></span><br><span class="line">	QMap&lt;<span class="type">int</span>, QMap&lt;QString, QVector&lt;<span class="type">int</span>&gt;&gt;&gt;G_DFA;<span class="comment">//DFA的存储结构</span></span><br><span class="line">	QMap&lt;<span class="type">int</span>, QMap&lt;QString, QVector&lt;<span class="type">int</span>&gt;&gt;&gt;G_NFA_change;<span class="comment">//也是NFA的存储结构，是转换DFA的时候用到的</span></span><br><span class="line">	QMap&lt;<span class="type">int</span>, QSet&lt;<span class="type">int</span>&gt;&gt; Epsilon_Closure();<span class="comment">//NFA中的所有点的Epsilon闭包</span></span><br><span class="line">	QSet&lt;<span class="type">int</span>&gt; <span class="title function_">Char_Tran</span><span class="params">(QSet&lt;<span class="type">int</span>&gt; point_set, QString tempchar)</span>;<span class="comment">//一个集合根据一个字符转到下一个集合</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">NFAtoDFA</span><span class="params">()</span>;<span class="comment">//将NFA转DFA</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//DFA最小化</span></span><br><span class="line">	<span class="type">int</span> MinDFA_Points_num = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> MinDFA_Begin_Point = <span class="number">0</span>;</span><br><span class="line">	QVector&lt;<span class="type">int</span>&gt;MinDFA_End_Point;</span><br><span class="line">	QMap&lt;<span class="type">int</span>, QSet&lt;<span class="type">int</span>&gt;&gt; equal_set;<span class="comment">//存储每个点对应的等价集合（后面加的）</span></span><br><span class="line">	QMap&lt;<span class="type">int</span>, QMap&lt;QString, QVector&lt;<span class="type">int</span>&gt;&gt;&gt;G_Min_DFA;<span class="comment">//最小化DFA的存储结构</span></span><br><span class="line">	QMap&lt;<span class="type">int</span>, QSet&lt;<span class="type">int</span>&gt;&gt;Min_DFA_point;<span class="comment">//最小化DFA中的点DFA中的点集合.</span></span><br><span class="line">	QSet&lt;<span class="type">int</span>&gt; <span class="title function_">Char_Tran2</span><span class="params">(QSet&lt;<span class="type">int</span>&gt;point_set, QString tempchar)</span>;<span class="comment">//一个等价集合根据一个字符转到下一个等价集合（不用加闭包）</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">Min_DFA</span><span class="params">()</span>;<span class="comment">//最小化DFA</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出代码</span></span><br><span class="line">	QString <span class="title function_">Output_Code</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">//输出NFA,DFA,minDFA的表格</span></span><br><span class="line">	QString <span class="title function_">Display</span><span class="params">(<span class="type">int</span> choice)</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">QVector&lt;QString&gt; <span class="title function_">Preprocess</span><span class="params">(QVector&lt;QString&gt; Input)</span>;<span class="comment">//预处理一下</span></span><br></pre></td></tr></table></figure>
<h3 id="预处理部分">预处理部分</h3>
<h4 id="思路">思路</h4>
<p><strong>1、输入处理</strong>：</p>
<p>我们先读取用户输入的正则表达式，然后根据换行符分割每一个正则表达式，我们先使用数据类型为
<code>QVector&lt;QString&gt;</code> 的对象 <code>Input</code>
接受分割之后的每一个正则表达式（此时的正则表达式中包含不需要生成 NFA 和
DFA 的命名表达式以及需要生成 NFA 和 DFA
的正则表达式）。我们在处理完输入之后，开始遍历 <code>Input</code>
中的每一个表达式，对于每一个表达式，我们先去除每一个表达式中的空格，避免后续处理中的一些不必要的字符。</p>
<p><strong>2、处理命名标识符</strong>：</p>
<p>我们在遍历 <code>Input</code>
中的每一个表达式的时候，我们要先处理表达式中的引用。我们存储引用的头部以及其对应的内容的是数据结构类型为
<code>QHash&lt;QString, QString&gt;</code> 的对象
<code>Definitions</code>，我们在遍历
<code>Definitions.keys()</code>（目前所存储的命名表达式的头部），如果表达式中包含某个命名表达式的头部，我们就将表达式里面的命名用“$$”标记，比如如果表达式中引用了命名表达式的头部“digit”，就会将“digit”替换为
<code>$digit$</code> 以便后续的识别和处理。</p>
<p><strong>3、处理字符范围符号（中括号）</strong>：</p>
<p>我们在表达式中识别到中括号的时候，程序会将其内容转换为选择（<code>|</code>）符号的形式。例如
<code>[a-c]</code> 会被转化为 <code>(a|b|c)</code>
的形式。算法中我们使用 <code>QChar</code> 的对象 <code>begin</code> 和
<code>end</code> 来记录区间的起止字符，如果识别到 ‘-’
符号，就会展开所有的字符。处理完区间之后我们加入 <code>)</code>。</p>
<p><strong>4、处理正闭包符号（+）</strong>：</p>
<p>如果遇到 <code>+</code> 且不是转义后的（即不是
<code>\+</code>），则判断其前面字符：如果前面的字符不是括号
<code>)</code> 或 <code>$</code>，直接将前一个字符重复一次并添加
<code>*</code>，以实现正闭包的效果。如果是括号
<code>)</code>，则需要找到对应的左括号，将整个子表达式包裹起来后添加
<code>*</code>。如果是
<code>$</code>（即命名标识符的标记），则找到匹配的
<code>$</code>，将标识符重复并添加 <code>*</code>。</p>
<p><strong>5、处理可选符号（?）</strong>：</p>
<p>遇到 <code>?</code>
时，表示前面的内容是可选的。如果前面的字符不是括号 <code>)</code> 或
<code>$</code>，直接将前面的字符包裹在 <code>()</code> 内，并在后面加上
<code>|$epsilon$)</code>，表示该字符可有可无。如果前面的字符是括号
<code>)</code> 或 <code>$</code>，则找到对应的起始位置，将整个内容包裹在
<code>()</code> 内并添加可选符。</p>
<p><strong>6、连接符（+）的添加</strong>：</p>
<p>在处理完上述运算符后，为了便于后续表达式的匹配，代码在某些情况下自动在两个字符之间添加
<code>+</code>，表示连接操作。根据正则表达式的形式，我们添加连接符号的逻辑如下：从表达式的
<code>=</code> 后面开始遍历，遍历到
<code>(</code>、<code>|</code>、<code>\</code>（转义字符）的时候，我们不需要在其后面添加连接符号；如果本字符后面的符号是
<code>)</code>、<code>|</code>、<code>*</code>
的时候，我们不需要在本字符的后面添加连接符号。其他情况下的时候我们就可以在本字符的后面添加连接符。</p>
<p><strong>7、命名与定义的处理</strong>：</p>
<p>处理后的表达式如果不是以 <code>_</code>
开头的，表示这个表达式是命名表达式，会将会存入 <code>Definitions</code>
中，键为命名标识符，值为对应的正则表达式。如果表达式以 <code>_</code>
开头，表示这是主表达式，需要生成 DFA 图，将其存入数据类型为
<code>QVector&lt;QString&gt;</code> 的对象 <code>processed</code>
向量中。对于主表达式中的标识符，进一步解析其名称与数值，将其保存到
<code>TokenID</code> 中，便于后续的词法分析器生成。</p>
<p><strong>8、处理结果返回</strong>：</p>
<p>处理完所有的表达式之后，我们返回存储主正则表达式的对象
<code>processed</code>。</p>
<h4 id="代码">代码</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="title function_">Preprocess</span><span class="params">(QVector&lt;QString&gt; Input)</span></span><br><span class="line">&#123;</span><br><span class="line">	QVector&lt;QString&gt; processed;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> temp : Input)</span><br><span class="line">	&#123;</span><br><span class="line">		QString temp_pro; temp_pro.clear();</span><br><span class="line">		temp = temp.remove(<span class="string">&#x27; &#x27;</span>);<span class="comment">//去掉空格</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> key : Definitions.keys())<span class="comment">//标识一下命名。使用$$标识</span></span><br><span class="line">			temp.replace(key, <span class="string">&#x27;$&#x27;</span> + key + <span class="string">&#x27;$&#x27;</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; temp.size(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (temp[i] == <span class="string">&#x27;[&#x27;</span>) <span class="comment">//读到[，将里面的内容处理成选择（|）符号</span></span><br><span class="line">			&#123;</span><br><span class="line">				temp_pro += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">				QChar begin = <span class="string">&#x27; &#x27;</span>, end = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">				i++;</span><br><span class="line">				<span class="type">bool</span> flag_to = <span class="literal">false</span>;<span class="comment">//中间的‘-’号是否有的标志</span></span><br><span class="line">				<span class="keyword">while</span> (i &lt; temp.size() &amp;&amp; temp[i] != <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (temp[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">						flag_to = <span class="literal">true</span>;</span><br><span class="line">						i++; <span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					begin == <span class="string">&#x27; &#x27;</span> ? begin = temp[i] : end = temp[i];</span><br><span class="line">					i++;</span><br><span class="line">					<span class="keyword">if</span> (end == <span class="string">&#x27; &#x27;</span> &amp;&amp; temp[i] != <span class="string">&#x27;]&#x27;</span>)<span class="keyword">continue</span>;<span class="comment">//凑够两个字符在处理,但是如果只剩下一个的时候就直接处理</span></span><br><span class="line">					<span class="keyword">if</span> (flag_to) &#123;</span><br><span class="line">						<span class="keyword">for</span> (QChar temp_char = begin; temp_char &lt;= end; temp_char = QChar(temp_char.unicode() + <span class="number">1</span>))</span><br><span class="line">							temp_pro += temp_char, temp_pro += <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">						flag_to = <span class="literal">false</span>;<span class="comment">//使用完之后要修改为false</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">//没有中间的&#x27;-&#x27;号的标志的时候，我们就只处理一个或两个字符，</span></span><br><span class="line">						temp_pro = temp_pro + begin + <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">						<span class="keyword">if</span> (end != <span class="string">&#x27; &#x27;</span>)temp_pro += end + <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					begin = end = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				temp_pro[temp_pro.size() - <span class="number">1</span>] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (temp[i] == <span class="string">&#x27;+&#x27;</span> &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; temp[i - <span class="number">1</span>] != <span class="string">&#x27;\\&#x27;</span>)<span class="comment">//处理一下正闭包符号</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> pos = temp_pro.size() - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (temp_pro[pos] != <span class="string">&#x27;)&#x27;</span> &amp;&amp; temp_pro[pos] != <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">					temp_pro += temp_pro[temp_pro.size() - <span class="number">1</span>];</span><br><span class="line">					temp_pro += <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (temp_pro[pos] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">						<span class="type">int</span> temp_pos = pos;</span><br><span class="line">						QString ct;</span><br><span class="line">						<span class="keyword">do</span> &#123;</span><br><span class="line">							ct = temp_pro[temp_pos] + ct;</span><br><span class="line">							temp_pos--;</span><br><span class="line">						&#125; <span class="keyword">while</span> (temp_pro[temp_pos] != <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">						temp_pro = temp_pro + <span class="string">&#x27;(&#x27;</span> + ct + <span class="string">&quot;*&quot;</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (temp_pro[pos] == <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">						<span class="type">int</span> temp_pos = pos;</span><br><span class="line">						QString ct;</span><br><span class="line">						<span class="keyword">do</span> &#123;</span><br><span class="line">							ct = temp_pro[temp_pos] + ct;</span><br><span class="line">							temp_pos--;</span><br><span class="line">						&#125; <span class="keyword">while</span> (temp_pro[temp_pos] != <span class="string">&#x27;$&#x27;</span>);</span><br><span class="line">						temp_pro = temp_pro + <span class="string">&#x27;$&#x27;</span> + ct + <span class="string">&quot;*&quot;</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (temp[i] == <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> pos = temp_pro.size() - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (temp_pro[pos] != <span class="string">&#x27;)&#x27;</span> &amp;&amp; temp_pro[pos] != <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">					temp_pro.insert(pos, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">					temp_pro = temp_pro + <span class="string">&#x27;|&#x27;</span> + <span class="string">&quot;$epsilon$&quot;</span> + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="type">int</span> temp_pos = pos;</span><br><span class="line">					<span class="keyword">if</span> (temp_pro[pos] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">						<span class="keyword">while</span> (temp_pro[temp_pos] != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">							temp_pos--;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (temp_pro[pos] == <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">						temp_pos -= <span class="number">1</span>;</span><br><span class="line">						<span class="keyword">while</span> (temp_pro[temp_pos] != <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">							temp_pos--;</span><br><span class="line">					&#125;</span><br><span class="line">					temp_pro.insert(temp_pos, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">					temp_pro = temp_pro + <span class="string">&#x27;|&#x27;</span> + <span class="string">&quot;$epsilon$&quot;</span> + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				temp_pro += temp[i];</span><br><span class="line">		&#125;</span><br><span class="line">		QString temp_pro2; temp_pro2.clear();</span><br><span class="line">		temp_pro2 += temp_pro.split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">0</span>] + <span class="string">&quot;=&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = temp_pro.indexOf(<span class="string">&quot;=&quot;</span>) + <span class="number">1</span>; i &lt; temp_pro.length(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			temp_pro2 += temp_pro[i];</span><br><span class="line">			<span class="keyword">if</span> (temp_pro[i] == <span class="string">&#x27;(&#x27;</span> || temp_pro[i] == <span class="string">&#x27;|&#x27;</span> || temp_pro[i] == <span class="string">&#x27;\\&#x27;</span>)<span class="comment">//不能在后面添加的符号，有点那什么的算法，想了半天才明白的</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (temp_pro[i] == <span class="string">&#x27;$&#x27;</span>)&#123;</span><br><span class="line">					i += <span class="number">1</span>; temp_pro2 += temp_pro[i];</span><br><span class="line">					<span class="keyword">while</span> (temp_pro[i] != <span class="string">&#x27;$&#x27;</span>)&#123;</span><br><span class="line">						i++;</span><br><span class="line">						temp_pro2 += temp_pro[i];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (i + <span class="number">1</span> &lt; temp_pro.length() &amp;&amp; temp_pro[i + <span class="number">1</span>] != <span class="string">&#x27;)&#x27;</span> &amp;&amp; temp_pro[i + <span class="number">1</span>] != <span class="string">&#x27;|&#x27;</span> &amp;&amp; temp_pro[i + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>)<span class="comment">//不能在前面添加的符号</span></span><br><span class="line">					temp_pro2 += <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//qDebug() &lt;&lt; temp_pro2;</span></span><br><span class="line">		<span class="keyword">if</span> (temp_pro2[<span class="number">0</span>] != <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">			QStringList def_list = temp_pro2.split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">			Definitions[def_list[<span class="number">0</span>]] = def_list[<span class="number">1</span>];<span class="comment">//添加一下命名的定义和对应的正则表达式</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; def_list[<span class="number">1</span>].size(); i++) &#123;</span><br><span class="line">				<span class="comment">//遍历字符串处理一下,命名仅支持中括号定义</span></span><br><span class="line">				<span class="keyword">if</span> (def_list[<span class="number">1</span>][i].isLetterOrNumber()) <span class="comment">//字符是字母或者数字</span></span><br><span class="line">					Definitions_char[def_list[<span class="number">0</span>]].append(def_list[<span class="number">1</span>][i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			processed.append(temp_pro2);<span class="comment">//保存主表达式</span></span><br><span class="line">			<span class="comment">//处理正则表达式的头部（感觉没什么用）</span></span><br><span class="line">			QStringList strlist = temp_pro2.split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">			<span class="type">int</span> num = <span class="number">0</span>; <span class="type">bool</span> falg = <span class="literal">true</span>;</span><br><span class="line">			QString name; name.clear();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; strlist[<span class="number">0</span>].size(); i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (strlist[<span class="number">0</span>][i].isNumber()) &#123;</span><br><span class="line">					num *= <span class="number">10</span>;</span><br><span class="line">					num += (<span class="type">int</span>(strlist[<span class="number">0</span>][i].toLatin1()) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">					falg = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (strlist[<span class="number">0</span>][i].isLetter() &amp;&amp; falg)</span><br><span class="line">					name += strlist[<span class="number">0</span>][i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//qDebug() &lt;&lt; name &lt;&lt; num;</span></span><br><span class="line">			<span class="keyword">if</span> (strlist[<span class="number">0</span>][strlist[<span class="number">0</span>].size() - <span class="number">1</span>] != <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">				TokenID[name] = num;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				QString temp_char;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strlist[<span class="number">1</span>].size(); i++) &#123;</span><br><span class="line">					temp_char.clear();</span><br><span class="line">					<span class="keyword">if</span> (strlist[<span class="number">1</span>][i] == <span class="string">&#x27;(&#x27;</span> || strlist[<span class="number">1</span>][i] == <span class="string">&#x27;)&#x27;</span> || strlist[<span class="number">1</span>][i] == <span class="string">&#x27;+&#x27;</span> || strlist[<span class="number">1</span>][i] == <span class="string">&#x27;*&#x27;</span> || strlist[<span class="number">1</span>][i] == <span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">if</span> (strlist[<span class="number">1</span>][i] == <span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">						temp_char += strlist[<span class="number">1</span>][i + <span class="number">1</span>], i += <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						temp_char += strlist[<span class="number">1</span>][i];</span><br><span class="line">					TokenID[temp_char] = num++;</span><br><span class="line">					<span class="comment">//qDebug() &lt;&lt; temp_char &lt;&lt; TokenID[temp_char];</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成nfa部分">生成NFA部分</h3>
<h4 id="思路-1">思路</h4>
<p><strong>1. 初始化与优先级表定义</strong> 代码中定义了两个
<code>QMap</code> 数据结构来表示操作符的栈内优先度 <code>Isp</code>
和栈外优先度
<code>Icp</code>。这些优先级决定了何时应该执行栈中的运算符，何时新运算符可以入栈。</p>
<ul>
<li><strong>栈内优先度
(<code>Isp</code>)</strong>：用于表示栈中已有的操作符的优先级。</li>
<li><strong>栈外优先度
(<code>Icp</code>)</strong>：用于表示新操作符的优先级。</li>
</ul>
<p>我们根据正则表达式符号的优先级别定义各个符号的栈内外优先级，如以下代码所示：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> QMap&lt;QChar, <span class="type">int</span>&gt;Isp = &#123; &#123;<span class="string">&#x27;#&#x27;</span>,<span class="number">0</span>&#125;, &#123;<span class="string">&#x27;(&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;*&#x27;</span>,<span class="number">7</span>&#125;,&#123;<span class="string">&#x27;+&#x27;</span>,<span class="number">5</span>&#125;,&#123;<span class="string">&#x27;|&#x27;</span>,<span class="number">3</span>&#125;,&#123;<span class="string">&#x27;)&#x27;</span>,<span class="number">8</span>&#125; &#125;;<span class="comment">//栈内优先度</span></span><br><span class="line"><span class="type">static</span> QMap&lt;QChar, <span class="type">int</span>&gt;Icp = &#123; &#123;<span class="string">&#x27;#&#x27;</span>,<span class="number">0</span>&#125;, &#123;<span class="string">&#x27;(&#x27;</span>,<span class="number">8</span>&#125;,&#123;<span class="string">&#x27;*&#x27;</span>,<span class="number">6</span>&#125;,&#123;<span class="string">&#x27;+&#x27;</span>,<span class="number">4</span>&#125;,&#123;<span class="string">&#x27;|&#x27;</span>,<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;)&#x27;</span>,<span class="number">1</span>&#125; &#125;;<span class="comment">//栈外优先度</span></span><br></pre></td></tr></table></figure> 其中的 <code>#</code> 为结束符。</p>
<p><strong>2. 操作符和操作数栈的初始化</strong></p>
<p>在这部分的算法中，在遍历正则表达式中的字符时，我们先生成每一个字符的
NFA 图像，如读到字符 <code>a</code> 的时候，我们生成的 NFA 图像如下：
<img src="https://s2.loli.net/2024/10/19/jA1gsTYLlGw52RE.png"
alt="image.png" /></p>
<p>字符 <code>a</code> 对应的操作数则是由 NFA 图像的起始状态和终态构成的
<code>QPair&lt;int,int&gt;</code>
对象，在进行运算的时候，操作的就是每个字符对应图像的起始状态和终态。给每一个字符生成
NFA 图像的函数 <code>Char_Graph()</code> 代码如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title function_">Graph::Char_Graph</span><span class="params">(QString tempchar)</span></span><br><span class="line">&#123;</span><br><span class="line">	QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;res;</span><br><span class="line">	res.first = ++Points_num, res.second = ++Points_num;</span><br><span class="line">	G[res.first][res.second] = tempchar;</span><br><span class="line">	<span class="keyword">if</span> (Char_set.indexOf(tempchar) == <span class="number">-1</span>)</span><br><span class="line">		Char_set.append(tempchar);<span class="comment">//将tempchar加入到字符集合中</span></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们使用两个栈来完成 NFA 的生成：</p>
<ul>
<li><code>QStack&lt;QPair&lt;int, int&gt;&gt; num</code>：操作数栈，用于存储
NFA 的起始状态和终态。</li>
<li><code>QStack&lt;QChar&gt; symbol</code>：操作符栈，用于存储操作符。</li>
</ul>
<p>初始化操作符栈 <code>symbol</code>，将
<code>#</code>（结束标志）压入栈，并在正则表达式末尾也添加一个
<code>#</code>。</p>
<p><strong>3. 正则表达式的遍历与处理</strong></p>
<p>遍历正则表达式，如果当前字符是一个操作符（如
<code>（</code>、<code>）</code>、<code>|</code>、<code>*</code>、<code>+</code>
等），我们进行优先级判断：</p>
<ul>
<li>如果操作符的栈外优先级高于当前栈顶操作符的栈内优先级，则直接将操作符压入栈中。</li>
<li>如果操作符的栈外优先级小于或等于当前栈顶操作符的栈内优先级，则需要根据操作符类型进行相应运算：
<ul>
<li>当遇到 <code>（</code> 或 <code>）</code>
时，需要对括号进行处理，跳过括号并继续处理。</li>
<li>当 <code>#</code> 出现且所有运算完成后，将最后一个结果保存为 NFA
的起始状态和终态，到了这里其实运算就结束了，为了方便后续算法的实现，我们在这里转换一下
NFA 的存储结构。在此之前模块生成 NFA 的时候，我们将 NFA 存储在结构
<code>QMap&lt;int, QMap&lt;int, QString&gt;&gt;</code>
中。在这里我们将其转换为
<code>QMap&lt;int, QMap&lt;QString, QVector&lt;int&gt;&gt;&gt;</code>
的对象
<code>G_NFA_change</code>（结构存储的内容已在项目设计中说明）。<code>G_NFA_change</code>
通过将目标状态作为键值，使得可以快速查找从某个状态通过特定输入到达的所有状态。然后我们执行<code>return</code>结束函数。</li>
<li>否则弹出栈顶符号并执行对应的操作：
<ul>
<li><code>*</code>：调用 <code>Repeat_Operation(num2)</code>
来执行闭包操作。</li>
<li><code>|</code>：调用 <code>Or_Operation(num1, num2)</code>
来执行选择操作。</li>
<li><code>+</code>：调用 <code>And_Operation(num1, num2)</code>
来执行连接操作。</li>
</ul></li>
</ul></li>
</ul>
<p>三个函数分别为操作符 <code>*</code>、<code>|</code>、<code>+</code>
对应的操作函数，实现的思路在后面会介绍。</p>
<p>如果当前字符是一个操作数（包括普通字符和转义字符），我们进行以下的判断和处理：</p>
<ul>
<li>处理 <code>$</code> 开头的标识符，即将 <code>$</code>
包裹的完整标识符取出，然后调用 <code>Char_Graph()</code> 生成对应的 NFA
片段。</li>
<li>如果遇到 <code>\</code>，表示这是一个转义字符，同样调用
<code>Char_Graph()</code> 函数。</li>
<li>对于普通字符，直接调用 <code>Char_Graph()</code>。</li>
</ul>
<p>将生成的操作数压入操作数栈中。</p>
<p><strong>4. 主要操作函数</strong></p>
<ul>
<li><strong><code>And_Operation()</code>
函数</strong>：将两个操作数进行连接运算，将第一个字符的终态指向第二个字符的起始状态，权值为
epsilon。如将字符 <code>r</code> 和字符 <code>s</code> 连接之后的 NFA
图像如下图所示： <img
src="https://s2.loli.net/2024/10/19/xIvdW6KizB9ZyfL.png"
alt="image.png" /> 函数实现的代码如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title function_">Graph::And_Operation</span><span class="params">(QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;n1, QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;n2)</span></span><br><span class="line">&#123;</span><br><span class="line">	QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;res;</span><br><span class="line">	res.first = n1.first;</span><br><span class="line">	res.second = n2.second;</span><br><span class="line">	G[n1.second][n2.first] = <span class="string">&quot;$epsilon$&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong><code>Or_Operation()</code> 函数</strong>：将两个操作数进行
<code>|</code>（在各项中选择）运算。我们通过一个样例来说明算法的执行结果：将字符
<code>r</code> 和 <code>s</code> 运算之后的 NFA 图像如下所示： <img
src="https://s2.loli.net/2024/10/19/xYkGp27OrPW18vZ.png"
alt="image.png" /> 函数实现的代码如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title function_">Graph::Or_Operation</span><span class="params">(QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;n1, QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;n2)</span></span><br><span class="line">&#123;</span><br><span class="line">	QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;res;</span><br><span class="line">	res.first = ++Points_num, res.second = ++Points_num;</span><br><span class="line">	G[res.first][n1.first] = <span class="string">&quot;$epsilon$&quot;</span>;</span><br><span class="line">	G[res.first][n2.first] = <span class="string">&quot;$epsilon$&quot;</span>;</span><br><span class="line">	G[n1.second][res.second] = <span class="string">&quot;$epsilon$&quot;</span>;</span><br><span class="line">	G[n2.second][res.second] = <span class="string">&quot;$epsilon$&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong><code>Repeat_Operation()</code>
函数</strong>：对操作数进行闭包运算，对字符 <code>r</code>
进行闭包操作生成的 NFA 的图像如下所示： <img
src="https://s2.loli.net/2024/10/19/4CLkjasZVm1QUTK.png"
alt="image.png" /> 函数的实现代码如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title function_">Graph::Repeat_Operation</span><span class="params">(QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;n1)</span></span><br><span class="line">&#123;</span><br><span class="line">	QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;res;</span><br><span class="line">	res.first = ++Points_num;</span><br><span class="line">	res.second = ++Points_num;</span><br><span class="line">	G[res.first][n1.first] = <span class="string">&quot;$epsilon$&quot;</span>;</span><br><span class="line">	G[res.first][res.second] = <span class="string">&quot;$epsilon$&quot;</span>;</span><br><span class="line">	G[n1.second][n1.first] = <span class="string">&quot;$epsilon$&quot;</span>;</span><br><span class="line">	G[n1.second][res.second] = <span class="string">&quot;$epsilon$&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="代码-1">代码</h4>
<p>根据正则表达式生成NFA的代码如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Graph::GenerateNFA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	QStack&lt;QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; num;<span class="comment">//操作数栈</span></span><br><span class="line">	QStack&lt;QChar&gt; symbol;<span class="comment">//操作符栈</span></span><br><span class="line">	symbol.push(<span class="string">&#x27;#&#x27;</span>), Reg_Exp += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = Reg_Exp.indexOf(<span class="string">&quot;=&quot;</span>) + <span class="number">1</span>; i &lt; Reg_Exp.length(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Reg_Exp[i] == <span class="string">&#x27;(&#x27;</span> || Reg_Exp[i] == <span class="string">&#x27;)&#x27;</span> || Reg_Exp[i] == <span class="string">&#x27;*&#x27;</span> || Reg_Exp[i] == <span class="string">&#x27;|&#x27;</span> || Reg_Exp[i] == <span class="string">&#x27;+&#x27;</span> || Reg_Exp[i] == <span class="string">&#x27;#&#x27;</span>)<span class="comment">//操作符</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Icp[Reg_Exp[i]] &gt; Isp[symbol.top()]) &#123;<span class="comment">//外面优先级高，先进站</span></span><br><span class="line">				symbol.push(Reg_Exp[i]); <span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//里面优先级高，先进行运算</span></span><br><span class="line">			<span class="keyword">while</span> (Icp[Reg_Exp[i]] &lt;= Isp[symbol.top()])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (Icp[Reg_Exp[i]] == <span class="number">1</span> &amp;&amp; Isp[symbol.top()] == <span class="number">1</span>) &#123;</span><br><span class="line">					i++, symbol.pop();</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (Icp[Reg_Exp[i]] == <span class="number">0</span> &amp;&amp; Isp[symbol.top()] == <span class="number">0</span>) &#123;<span class="comment">//弹出（）之后如果运算结束</span></span><br><span class="line">					QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;res = num.top();</span><br><span class="line">					Begin_Point = res.first;</span><br><span class="line">					End_Point = res.second;</span><br><span class="line"></span><br><span class="line">					<span class="comment">//转换一下NFA的存储结构</span></span><br><span class="line">					QMap&lt;<span class="type">int</span>, QMap&lt;<span class="type">int</span>, QString&gt;&gt; ::iterator it1;</span><br><span class="line">					<span class="keyword">for</span> (it1 = G.begin(); it1 != G.end(); it1++) &#123;</span><br><span class="line">						QMap&lt;<span class="type">int</span>, QString&gt;::iterator it2;</span><br><span class="line">						<span class="keyword">for</span> (it2 = it1.value().begin(); it2 != it1.value().end(); it2++) &#123;</span><br><span class="line">							G_NFA_change[it1.key()][it2.value()].append(it2.key());</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				QChar top_sym = symbol.top(); symbol.pop();<span class="comment">//弹出符号</span></span><br><span class="line">				QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;num2 = num.top(); num.pop();</span><br><span class="line">				QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; res;</span><br><span class="line">				<span class="keyword">if</span> (top_sym == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">					res = Repeat_Operation(num2);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (top_sym == <span class="string">&#x27;|&#x27;</span>) &#123;</span><br><span class="line">					QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;num1 = num.top(); num.pop();</span><br><span class="line">					res = Or_Operation(num1, num2);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (top_sym == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">					QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;num1 = num.top(); num.pop();</span><br><span class="line">					res = And_Operation(num1, num2);</span><br><span class="line">				&#125;</span><br><span class="line">				num.push(res);</span><br><span class="line">			&#125;</span><br><span class="line">			symbol.push(Reg_Exp[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			QString tempchar;</span><br><span class="line">			QPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;res;</span><br><span class="line">			<span class="keyword">if</span> (Reg_Exp[i] == <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">				tempchar += Reg_Exp[i++];</span><br><span class="line">				tempchar += Reg_Exp[i];</span><br><span class="line">				<span class="keyword">while</span> (Reg_Exp[i] != <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">					i++;</span><br><span class="line">					tempchar += Reg_Exp[i];</span><br><span class="line">				&#125;</span><br><span class="line">				res = Char_Graph(tempchar);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Reg_Exp[i] == <span class="string">&#x27;\\&#x27;</span>) &#123;<span class="comment">//读到转义</span></span><br><span class="line">				tempchar += Reg_Exp[i++];</span><br><span class="line">				tempchar += Reg_Exp[i];</span><br><span class="line">				res = Char_Graph(tempchar);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				tempchar += Reg_Exp[i];</span><br><span class="line">				res = Char_Graph(tempchar);</span><br><span class="line">			&#125;</span><br><span class="line">			num.push(res);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="生成dfa部分">生成DFA部分</h3>
<h4 id="思路-2">思路</h4>
<p><strong>1. Epsilon 闭包计算函数
<code>Epsilon_Closure()</code></strong></p>
<p>这个函数的目的是找到 NFA 中每个状态的 epsilon
闭包，也就是说从每个状态出发，通过任意数量的 epsilon
转移可以到达的所有状态。</p>
<p><strong>1.1广度优先搜索求闭包</strong></p>
<p>我们使用 <code>QMap&lt;int, QSet&lt;int&gt;&gt;</code> 结构的对象
<code>Res</code> 来存储每个状态对应的 epsilon 闭包。我们遍历每个 NFA
中的每个状态，对每个状态使用广度优先搜索，搜索的操作如下：</p>
<ul>
<li>对 NFA 的每个状态 <code>i</code>，使用队列 <code>S</code> 和标记表
<code>flag</code> 来执行广度优先搜索（BFS），以计算 <code>epsilon</code>
闭包。</li>
<li>初始时，将状态 <code>i</code> 入队列，并开始处理。</li>
<li>每次从队列中取出一个状态，将其插入结果 <code>Res[i]</code>
中，然后将通过 epsilon
转移可到达的并且未标记的状态加入队列中，并标记该状态。</li>
<li>这种方式确保所有从 <code>i</code> 出发通过 epsilon
转移可达的状态都被包含在 <code>Res[i]</code> 中。</li>
</ul>
<p><strong>1.2求闭包的代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;<span class="type">int</span>, QSet&lt;<span class="type">int</span>&gt;&gt; Graph::Epsilon_Closure()<span class="comment">//求出NFA中每个点的epsilon闭包</span></span><br><span class="line">&#123;</span><br><span class="line">	QMap&lt;<span class="type">int</span>, QSet&lt;<span class="type">int</span>&gt;&gt; Res;</span><br><span class="line">	QQueue&lt;<span class="type">int</span>&gt; S;<span class="comment">//广度优先的队列</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Points_num; i++) &#123;<span class="comment">//遍历每个点求epsilon闭包</span></span><br><span class="line">		S.clear(); S.enqueue(i);</span><br><span class="line">		QMap&lt;<span class="type">int</span>, <span class="type">bool</span>&gt;flag;</span><br><span class="line">		<span class="keyword">while</span> (!S.empty()) &#123;</span><br><span class="line">			<span class="type">int</span> first_point = S.dequeue();<span class="comment">//dequeue()可以从队列头部移除并返回第一个元素</span></span><br><span class="line">			Res[i].insert(first_point);</span><br><span class="line">			flag[first_point] = <span class="literal">true</span>;<span class="comment">//保存过的元素做标记</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G_NFA_change[first_point][<span class="string">&quot;$epsilon$&quot;</span>].size(); j++) &#123;</span><br><span class="line">				<span class="type">int</span> next_point = G_NFA_change[first_point][<span class="string">&quot;$epsilon$&quot;</span>][j];</span><br><span class="line">				<span class="keyword">if</span> (!flag[next_point])</span><br><span class="line">					S.enqueue(next_point);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 状态集的字符转移函数
<code>Char_Tran(QSet&lt;int&gt; point_set, QString tempchar)</code></strong></p>
<p>这个函数用于计算在 NFA 中，一个给定状态集在接受某个输入字符
<code>tempchar</code> 之后可以转移到的状态集。传入的
<code>point_set</code> 是一个状态集合，表示 DFA
当前的某个状态实际上由多个 NFA 状态组成。在函数中我们遍历状态集：</p>
<ul>
<li><p>对于 <code>point_set</code> 中的每个状态，找到所有通过
<code>tempchar</code>
转移可达的状态（注意<code>tempchar</code>不接受<code>$epsilon$</code>作为参数，因为我们已经求过所有状态的<code>epsilon</code>闭包，相当于我们已经对所有状态找过通过
<code>$epsilon$</code> 转移可达的状态）。</p></li>
<li><p>通过 <code>G_NFA_change</code> 查找每个状态在接收字符
<code>tempchar</code> 之后的目标状态，进而将这些状态的 epsilon
闭包添加到结果集 <code>Res</code> 中。</p></li>
</ul>
<p>遍历完成后我们返回结果集即可。</p>
<p><strong>2.1函数的代码</strong></p>
<p>函数的代码如下所示： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">QSet&lt;<span class="type">int</span>&gt; <span class="title function_">Graph::Char_Tran</span><span class="params">(QSet&lt;<span class="type">int</span>&gt; point_set, QString tempchar)</span><span class="comment">//在NFA中一个点集接收到权值tempchar之后可以转到的点集合</span></span><br><span class="line">&#123;</span><br><span class="line">	QSet&lt;<span class="type">int</span>&gt; Res;</span><br><span class="line">	<span class="keyword">if</span> (tempchar == <span class="string">&quot;$epsilon$&quot;</span>)<span class="comment">//不接受$epsilon$作为转移的权值，因为如果集合A经过epsilon到了另一个集合B，则集合B肯定是A的子集。</span></span><br><span class="line">		<span class="keyword">return</span> Res;</span><br><span class="line">	QSet&lt;<span class="type">int</span>&gt;::const_iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = point_set.begin(); it != point_set.end(); it++) &#123;</span><br><span class="line">		<span class="comment">//遍历集合中的所有点</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G_NFA_change[*it][tempchar].size(); i++) &#123;</span><br><span class="line">			<span class="comment">//一个点的epsilon闭包里面肯定包含自身，所以我们直接添加这个点的epsilon闭包即可</span></span><br><span class="line">			<span class="comment">//将下一个可以到达的点的epsilon闭包加到Res里面，QSet的等于号就是将另一个QSet的元素全部加到本集合里面</span></span><br><span class="line">			Res += Point_Epsilon_Closure[G_NFA_change[*it][tempchar][i]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>3. NFA 转化为 DFA 的主函数
<code>NFAtoDFA()</code></strong></p>
<p>这个函数实现了将 NFA 转换为 DFA 的整体逻辑，主要基于 epsilon
闭包、字符转移和广度优先搜索来生成新的状态集。函数的操作如下：</p>
<p><strong>3.1初始化</strong></p>
<ul>
<li><p>计算每个 NFA 状态的 epsilon 闭包，并将起始状态的 epsilon 闭包作为
DFA 的起始状态 <code>start_set</code>。</p></li>
<li><p>创建一个队列 <code>S</code> 来存储待处理的状态集及其在 DFA
中的编号。初始时将起始状态 <code>start_set</code> 作为 DFA
的第一个状态入队列。</p></li>
</ul>
<p><strong>3.2状态集遍历</strong></p>
<ul>
<li><p>通过循环，不断从队列中取出待处理的状态集
<code>temp_pair</code>，并为该状态集尝试每一个可能的输入字符
<code>tempchar</code>。</p></li>
<li><p>调用 <code>Char_Tran()</code> 函数来获取当前状态集在输入字符
<code>tempchar</code> 后的下一个状态集 <code>next_set</code>。</p></li>
</ul>
<p><strong>3.3 新状态集的判断与处理</strong></p>
<ul>
<li>如果 <code>next_set</code>
是空集，则说明该输入字符不导致任何状态转移，直接跳过。</li>
<li>如果 <code>next_set</code> 已经存在于已有的 DFA
状态集中，说明该状态集之前已被处理过，直接在 DFA
图中建立相应的状态转移。</li>
<li>如果 <code>next_set</code>
是新的状态集，分配一个新的编号给它，将其添加到 DFA 状态集
<code>DFA_point</code> 中，并将新的状态转移关系加入 DFA
图中。然后将新的状态集入队列等待进一步处理。</li>
</ul>
<p><strong>3.4添加DFA的终态</strong></p>
<p>​
处理完之后，我们需要保存一下DFA的结束状态，我们遍历DFA的状态，如果DFA的状态对应的NFA的状态集合中包含NFA的终态，则这个DFA状态是DFA的终态，保存在<code>QVector&lt;int&gt;DFA_End_Point</code>中。</p>
<h4 id="代码-2">代码</h4>
<p>函数的代码如下所示： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Graph::NFAtoDFA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Point_Epsilon_Closure = Epsilon_Closure();</span><br><span class="line">	QSet&lt;<span class="type">int</span>&gt; start_set = Point_Epsilon_Closure[Begin_Point];</span><br><span class="line">	QMap&lt;<span class="type">int</span>, QSet&lt;<span class="type">int</span>&gt;&gt;::const_iterator it;<span class="comment">//遍历</span></span><br><span class="line">	QQueue&lt;QPair&lt;QSet&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt;&gt;S;<span class="comment">//队列里存储的是NFA的点集合以及集合对应在DFA中的序号</span></span><br><span class="line">	DFA_Points_num = <span class="number">1</span>;</span><br><span class="line">	DFA_Begin_Point = <span class="number">1</span>;</span><br><span class="line">	S.enqueue(&#123; start_set, <span class="number">1</span> &#125;);</span><br><span class="line">	DFA_point[<span class="number">1</span>] = start_set;<span class="comment">//保存起点</span></span><br><span class="line">	<span class="keyword">while</span> (!S.empty()) &#123;</span><br><span class="line">		QPair&lt;QSet&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt;temp_pair = S.dequeue();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tempchar : Char_set) &#123;</span><br><span class="line">			QSet&lt;<span class="type">int</span>&gt; next_set = Char_Tran(temp_pair.first, tempchar);</span><br><span class="line">			<span class="keyword">if</span> (next_set.isEmpty())<span class="keyword">continue</span>;<span class="comment">//空集合跳过</span></span><br><span class="line">			<span class="type">bool</span> find_flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (it = DFA_point.begin(); it != DFA_point.end(); it++) &#123;<span class="comment">//遍历已有的点，看看next_set是否已存在</span></span><br><span class="line">				<span class="keyword">if</span> (it.value() == next_set) &#123;<span class="comment">//已存在</span></span><br><span class="line">					G_DFA[temp_pair.second][tempchar].append(it.key());</span><br><span class="line">					find_flag = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (find_flag) &#123;<span class="comment">//找不到</span></span><br><span class="line">				DFA_point[++DFA_Points_num] = next_set;</span><br><span class="line">				G_DFA[temp_pair.second][tempchar].append(DFA_Points_num);</span><br><span class="line">				S.enqueue(&#123; next_set ,DFA_Points_num &#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= DFA_Points_num; i++) &#123;<span class="comment">//判断DFA中的点对应的NFA的点集合中是否包含NFA的终态点</span></span><br><span class="line">		<span class="keyword">if</span> (DFA_point[i].contains(End_Point)) &#123;</span><br><span class="line">			DFA_End_Point.append(i);<span class="comment">//DFA图的终点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最小化dfa部分">最小化DFA部分</h3>
<h4 id="思路-3">思路</h4>
<p><strong>1. 函数
<code>Char_Tran2(QSet&lt;int&gt; point_set, QString tempchar)</code></strong></p>
<p>这个函数用于计算在最小化 DFA 中，一个给定状态集在接受某个输入字符
<code>tempchar</code> 之后可以转移到的状态集。</p>
<p>因为我们在最小化 DFA 之前，要先求出在原来的 DFA
中的每个状态的等价状态，并且将等价状态合并为一个状态，所以我们在这里使用跟用
NFA 生成 DFA 一样的状态集的字符转移函数。此时一个最小化 DFA
的状态也同样表示 DFA 中的一组状态（组内的状态均是 DFA
中的等价状态，可以合并）。函数中我们遍历状态集进行如下操作：</p>
<ul>
<li>对于给定的状态集 <code>point_set</code>，遍历每一个状态。</li>
<li>对每一个状态，查看它在接受字符 <code>tempchar</code>
后所能到达的状态，并将到达的状态的等价集合（由 <code>equal_set</code>
表示）加入结果集 <code>Res</code>。</li>
<li>最终返回能够通过该字符转移到的所有状态的等价集合。</li>
</ul>
<p><strong>1.1函数代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">QSet&lt;<span class="type">int</span>&gt;Graph::Char_Tran2(QSet&lt;<span class="type">int</span>&gt;point_set, QString tempchar) <span class="comment">//在DFA中一个点集接收到权值tempchar之后可以转到的点集合</span></span><br><span class="line">&#123;</span><br><span class="line">	QSet&lt;<span class="type">int</span>&gt; Res;</span><br><span class="line">	QSet&lt;<span class="type">int</span>&gt;::const_iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = point_set.begin(); it != point_set.end(); it++) &#123;</span><br><span class="line">		<span class="comment">//遍历集合中的所有点</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G_DFA[*it][tempchar].size(); i++) &#123;</span><br><span class="line">			<span class="comment">//遍历所有顶点,可以到达一个顶点也就可以到达其等价顶点</span></span><br><span class="line">			Res += equal_set[G_DFA[*it][tempchar][i]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 最小化 DFA 的主函数 <code>Min_DFA()</code></strong></p>
<p>函数 <code>Min_DFA</code> 的主要功能是将已经生成的 DFA
进行最小化处理。函数的功能主要分为两部分：第一部分主要是划分等价状态，第二部分是使用广度优先搜索来生成最小化
DFA。它的主要逻辑如下：：</p>
<p><strong>等价集合初始划分</strong></p>
<p>使用 <code>flag</code> 数据结构来存储每个状态的等价集合。初始时将 DFA
的状态分为两组：</p>
<ul>
<li><strong>非终态集合</strong> (<code>flag[1]</code>)</li>
<li><strong>终态集合</strong> (<code>flag[2]</code>)</li>
</ul>
<p>然后我们遍历 DFA 中的每个状态，检查其是否包含 NFA
的终态，如果包含，则将其放入终态集合，否则放入非终态集合。</p>
<p><strong>计算每个状态的转义状态</strong></p>
<p>使用 <code>Char_tran_state</code>
来存储每个状态根据字符的转义状态。遍历每个状态，通过字符集中的每一个字符，找到该状态对应的转义状态。如果该状态对于某个字符的目标状态已经存在于某个等价集合中，则保存该目标集合的标识。</p>
<p><strong>更新集合划分</strong></p>
<p>每得到一个状态的转移状态，我们就先检查其所在集合有没有转移状态：</p>
<ul>
<li>如果集合没有转移状态，我们就先将本状态的转移状态赋给集合。</li>
<li>如果集合有转移状态，我们就检查其所在集合的转义状态是否与本状态的转移状态一致。
<ul>
<li>如果不同，则将该状态从当前集合移除并且清空集合的转移状态，并尝试找到转义状态相同且接受状态一致的集合。</li>
<li>若找不到，则创建一个新的集合并将该状态加入其中，之后我们还要重新生成所有的字符转移状态。</li>
</ul></li>
</ul>
<p><strong>合并等价状态</strong></p>
<p>经过上面的循环之后，每个集合里面的状态都是等价状态。接下来，我们开始构建等价集合映射：</p>
<ul>
<li>使用 <code>equal_set</code>
数据结构，记录每个状态及其所属的最小化后的状态集合。</li>
<li>对于每个等价集合，将其中所有状态都标记为属于同一个等价集合。</li>
</ul>
<p><strong>使用广度优先搜索的方法构建最小化 DFA 图</strong></p>
<p>初始化时，我们将最小化后的起始状态集合加入队列中。然后使用广度优先生成最小化
DFA，算法如下：</p>
<ul>
<li>每次从队列中取出一个状态集合，遍历字符集，通过
<code>Char_Tran2</code>
函数获取当前状态集合接收字符后的目标状态集合。</li>
<li>如果目标状态集合为空，跳过该字符。</li>
<li>如果目标状态集合已经存在于最小化 DFA
中，则在当前状态与目标状态之间建立转换。</li>
<li>如果目标状态集合不存在，则创建新的状态编号并加入最小化 DFA。</li>
</ul>
<p><strong>确定最小化 DFA 的终态</strong></p>
<p>遍历最小化 DFA 的每个状态集合，检查该集合中是否包含原 DFA
中的终态。如果包含，则将该状态标记为最小化 DFA 的终态。</p>
<h4 id="代码-3">代码</h4>
<p>代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Graph::Min_DFA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	QMap&lt;<span class="type">int</span>, QSet&lt;<span class="type">int</span>&gt;&gt; flag;<span class="comment">//存储和判断DFA中的每一个点的等价点集合，初始时S1是非终态集合，S2是终态集合</span></span><br><span class="line">	QMap&lt;<span class="type">int</span>, QVector&lt;<span class="type">int</span>&gt;&gt; Char_tran_state;<span class="comment">//存储每一个点根据字符的转义状态</span></span><br><span class="line">	QMap&lt;<span class="type">int</span>, QVector&lt;<span class="type">int</span>&gt;&gt;flag_vector;<span class="comment">//每一个集合对应的字符转义状态</span></span><br><span class="line">	<span class="type">int</span> flag_num = <span class="number">2</span>;<span class="comment">//集合数量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= DFA_Points_num; i++) &#123;<span class="comment">//判断DFA中的点对应的NFA的点集合中是否包含NFA的终态点</span></span><br><span class="line">		<span class="keyword">if</span> (DFA_point[i].contains(End_Point)) &#123;</span><br><span class="line">			flag[<span class="number">2</span>].insert(i);<span class="comment">//包含终态，将终态的点全保存在flag[2]中</span></span><br><span class="line">			<span class="comment">//DFA_End_Point.append(i);//DFA图的终点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			flag[<span class="number">1</span>].insert(i);<span class="comment">//不包含终态</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//先所有点求字符转义状态</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= DFA_Points_num; i++) &#123;</span><br><span class="line">		QMap&lt;<span class="type">int</span>, QSet&lt;<span class="type">int</span>&gt;&gt;::iterator it;</span><br><span class="line">		<span class="keyword">if</span> (!Char_tran_state[i].isEmpty())Char_tran_state.clear();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; Char_set.size(); j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!G_DFA[i][Char_set[j]].isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">for</span> (it = flag.begin(); it != flag.end(); it++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (it.value().contains(G_DFA[i][Char_set[j]][<span class="number">0</span>])) &#123;</span><br><span class="line">						Char_tran_state[i].append(it.key());</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				Char_tran_state[i].append(<span class="number">0</span>);<span class="comment">//0占位</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//点的转义集合完成,先找到点位于那个集合</span></span><br><span class="line">		<span class="keyword">for</span> (it = flag.begin(); it != flag.end(); it++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (it.value().contains(i))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">if</span> (flag_vector[it.key()].isEmpty()) &#123;</span><br><span class="line">			<span class="comment">//qDebug() &lt;&lt; it.key();</span></span><br><span class="line">			<span class="comment">//集合没有转义状态，将点的转义状态赋值给集合</span></span><br><span class="line">			flag_vector[it.key()] = Char_tran_state[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (flag_vector[it.key()] != Char_tran_state[i]) &#123;</span><br><span class="line">			<span class="comment">//点的转移状态和集合的转义状态不相同，则从集合中去除这个点，并且要更新</span></span><br><span class="line">			<span class="comment">//这个集合里面所有的点的转义状态，还要删除这个集合的转义状态</span></span><br><span class="line">			<span class="comment">//if (flag[it.key()].size() == 1) &#123;</span></span><br><span class="line">			<span class="comment">//	//如果集合中只有一个状态，但是状态的转移集合和集合的转移状态不同，就是状态的转移集合更新了,</span></span><br><span class="line">			<span class="comment">//	//此时集合的转移状态也应该更新</span></span><br><span class="line">			<span class="comment">//	flag_vector[it.key()] = Char_tran_state[i];</span></span><br><span class="line">			<span class="comment">//	continue;</span></span><br><span class="line">			<span class="comment">//&#125;</span></span><br><span class="line">			flag[it.key()].remove(i);</span><br><span class="line">			flag_vector[it.key()].clear();</span><br><span class="line">			<span class="comment">//之后找一下目前有没有集合的转移状态和这个点相同并且集合里面的点的接受状态要一样（要么都是接受状态，要么都不是接受状态），</span></span><br><span class="line">			<span class="comment">// 如果有则将这个点加入集合，没有则需要给这个点新创一个集合，新创集合的转移状态会在下一次循环到这个点的时候赋值</span></span><br><span class="line">			QMap&lt;<span class="type">int</span>, QSet&lt;<span class="type">int</span>&gt;&gt;::iterator it1;</span><br><span class="line">			<span class="type">bool</span> temp_find = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (it1 = flag.begin(); it1 != flag.end(); it1++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (flag_vector[it1.key()] == Char_tran_state[i] &amp;&amp; </span><br><span class="line">					DFA_End_Point.contains(i) == DFA_End_Point.contains(*flag[it1.key()].begin())) &#123;</span><br><span class="line">					temp_find = <span class="literal">false</span>;</span><br><span class="line">					flag[it1.key()].insert(i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp_find)</span><br><span class="line">				flag[++flag_num].insert(i);</span><br><span class="line">			i = <span class="number">0</span>;<span class="comment">//重新在生成一次字符的转义状态</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//合并等价状态（使用 equal_set 来存储每个状态与其等价集合，即每个状态属于哪个最小化后的状态集合）</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= flag_num; i++) &#123;<span class="comment">//分别遍历两个集合</span></span><br><span class="line">		QSet&lt;<span class="type">int</span>&gt;::const_iterator it1;</span><br><span class="line">		<span class="keyword">for</span> (it1 = flag[i].begin(); it1 != flag[i].end(); it1++) &#123;</span><br><span class="line">			equal_set[*it1] += flag[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//用类似广度搜索的方式生成最小化DFA图</span></span><br><span class="line">	QQueue&lt;QPair&lt;QSet&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt;&gt;S; <span class="comment">//队列里存储的是DFA点的等价集合以及集合对应在minDFA中的序号</span></span><br><span class="line">	QSet&lt;<span class="type">int</span>&gt;start_set = equal_set[DFA_Begin_Point];</span><br><span class="line">	MinDFA_Points_num = <span class="number">1</span>;</span><br><span class="line">	MinDFA_Begin_Point = <span class="number">1</span>;</span><br><span class="line">	Min_DFA_point[<span class="number">1</span>] = start_set;<span class="comment">//保存起点</span></span><br><span class="line">	QMap&lt;<span class="type">int</span>, QSet&lt;<span class="type">int</span>&gt;&gt;::const_iterator it;<span class="comment">//遍历</span></span><br><span class="line">	S.enqueue(&#123; start_set,MinDFA_Begin_Point &#125;);</span><br><span class="line">	<span class="keyword">while</span> (!S.empty()) &#123;</span><br><span class="line">		QPair&lt;QSet&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt;temp_pair = S.dequeue();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tempchar : Char_set) &#123;</span><br><span class="line">			QSet&lt;<span class="type">int</span>&gt; next_set = Char_Tran2(temp_pair.first, tempchar);</span><br><span class="line">			<span class="keyword">if</span> (next_set.isEmpty())<span class="keyword">continue</span>;<span class="comment">//空集合跳过</span></span><br><span class="line">			<span class="type">bool</span> find_flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (it = Min_DFA_point.begin(); it != Min_DFA_point.end(); it++) &#123;<span class="comment">//遍历已有的点，看看next_set是否已存在</span></span><br><span class="line">				<span class="keyword">if</span> (it.value() == next_set) &#123;<span class="comment">//已存在</span></span><br><span class="line">					G_Min_DFA[temp_pair.second][tempchar].append(it.key());</span><br><span class="line">					find_flag = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (find_flag) &#123;<span class="comment">//找不到</span></span><br><span class="line">				Min_DFA_point[++MinDFA_Points_num] = next_set;</span><br><span class="line">				G_Min_DFA[temp_pair.second][tempchar].append(MinDFA_Points_num);</span><br><span class="line">				S.enqueue(&#123; next_set ,MinDFA_Points_num &#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MinDFA_Points_num; i++) &#123;</span><br><span class="line">		<span class="comment">//找到最小化DFA的终点,方法是判断每个minDFA的点对应DFA中的点是否包含DFA的终点，利用DFA_End_Point判断</span></span><br><span class="line">		QSet&lt;<span class="type">int</span>&gt;::const_iterator it;</span><br><span class="line">		<span class="keyword">for</span> (it = Min_DFA_point[i].begin(); it != Min_DFA_point[i].end(); it++) &#123;</span><br><span class="line">			<span class="comment">//遍历点对应的集合的里面的点。</span></span><br><span class="line">			<span class="keyword">if</span> (DFA_End_Point.indexOf(*it) != <span class="number">-1</span>) &#123;</span><br><span class="line">				MinDFA_End_Point.append(i);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成词法分析程序部分">生成词法分析程序部分</h3>
<h4 id="思路-4">思路</h4>
<p>这个模块实现了将最小化后的 DFA 转换为一个 C++
语言的词法分析器代码，用于分析输入字符串并判断其是否符合正则表达式的要求。代码生成了一个函数
<code>bool Analysis(string str)</code>，通过模拟状态转移的过程，判断输入的字符串是否能被最小化
DFA 接受。生成词法分析程序的思路如下：</p>
<p><strong>1.生成函数结构</strong></p>
<ul>
<li>生成词法分析函数的初始部分，返回类型为 <code>bool</code>，函数名为
<code>Analysis</code>，参数为字符串 <code>str</code>。</li>
</ul>
<p><strong>2.初始化</strong></p>
<ul>
<li>初始化部分包括状态变量
<code>State</code>，表示当前的状态编号，以及变量
<code>pos</code>，表示当前处理的输入字符串位置。</li>
</ul>
<p><strong>3.循环控制</strong></p>
<ul>
<li>使用 <code>while (pos &lt; str.length())</code>
进行逐字符处理，遍历整个输入字符串，逐步进行状态转移。</li>
</ul>
<p><strong>3.状态转移逻辑</strong></p>
<ul>
<li>使用 <code>switch (State)</code> 控制当前状态。对于每个状态
<code>i</code>，生成一个 <code>case i:</code>，用来表示当前 DFA 处于状态
<code>i</code> 的情况。</li>
<li>对应每个状态，会根据输入字符进行转移，使用
<code>switch (str[pos])</code>
处理不同输入字符的转移逻辑。后面我们会进入字符转移逻辑。</li>
</ul>
<p><strong>4.字符转移逻辑</strong></p>
<ul>
<li>对于每个可能的输入字符（如果识别到命名定义，则要转入处理命名定义），生成一个
<code>case</code>，表示该字符的转移逻辑。</li>
<li>调用 DFA 图 <code>G_Min_DFA</code> 中保存的转移关系，找到状态
<code>i</code> 在接收特定字符后应该转移到的状态。</li>
<li>更新状态 <code>State</code>，并使用 <code>break</code>
跳出该字符处理分支。</li>
</ul>
<p><strong>5.处理命名定义</strong></p>
<ul>
<li>如果 DFA 的某个转移涉及到通过命名定义（例如通过 <code>$digit$</code>
来表示所有数字字符），那么首先移除
<code>$</code>，然后检查是否有定义（通过
<code>Definitions_char</code>）。</li>
<li>如果存在，则为每个定义的字符生成一个 <code>case</code>
分支。这部分代码通过展开定义，将命名标识符转换为各个可能的具体字符，使得最终生成的代码涵盖所有可能的字符转移。</li>
</ul>
<p><strong>6.默认处理逻辑</strong></p>
<ul>
<li>通过 <code>default:</code>
分支处理任何未在状态转移表中定义的字符：遍历到未在状态转移表中定义的字符，则将状态设置为
<code>MinDFA_Points_num + 1</code>，表示此字符不属于接受字符。</li>
</ul>
<p><strong>7.字符遍历结束后的状态检查</strong></p>
<ul>
<li>循环遍历结束后，使用 <code>if</code> 判断当前状态是否为终态。</li>
<li>如果 <code>State</code>
处于终态集合（<code>MinDFA_End_Point</code>），返回
<code>true</code>，表示字符串符合正则表达式要求。</li>
<li>否则返回 <code>false</code>，表示输入字符串不符合要求。</li>
</ul>
<h4 id="代码-4">代码</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">QString <span class="title function_">Graph::Output_Code</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	QString Res;</span><br><span class="line">	Res.clear();</span><br><span class="line">	Res += <span class="string">&quot;bool Analysis (string str)\r\n&#123;\r\n&quot;</span>;</span><br><span class="line">	Res += <span class="string">&quot;     int State = 1, pos = 0;\r\n&quot;</span>;</span><br><span class="line">	Res += <span class="string">&quot;     while (pos &lt; str.length())\r\n&quot;</span>;</span><br><span class="line">	Res += <span class="string">&quot;     &#123;\r\n&quot;</span>;</span><br><span class="line">	Res += <span class="string">&quot;          switch (State)\r\n          &#123;\r\n&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MinDFA_Points_num; i++) &#123;</span><br><span class="line">		Res += <span class="string">&quot;          case &quot;</span> + QString::number(i) + <span class="string">&quot;:\r\n&quot;</span>;</span><br><span class="line">		<span class="comment">//if (!G_Min_DFA[i].isEmpty())//后面改</span></span><br><span class="line">		Res += <span class="string">&quot;              switch (str[pos])\r\n              &#123;\r\n&quot;</span>;</span><br><span class="line">		<span class="comment">//加入判断代码</span></span><br><span class="line">		QMap&lt;QString, QVector&lt;<span class="type">int</span>&gt;&gt;::iterator it;</span><br><span class="line">		<span class="keyword">for</span> (it = G_Min_DFA[i].begin(); it != G_Min_DFA[i].end(); it++) &#123;</span><br><span class="line">			QString temp = it.key();</span><br><span class="line">			<span class="keyword">if</span> (Definitions_char[temp.remove(<span class="string">&#x27;$&#x27;</span>)].isEmpty()) &#123;</span><br><span class="line">				<span class="comment">//不是命名定义</span></span><br><span class="line">				Res += <span class="string">&quot;              case &#x27;&quot;</span> + temp.remove(<span class="string">&#x27;\\&#x27;</span>) + <span class="string">&quot;&#x27; :\r\n&quot;</span>;</span><br><span class="line">				Res += <span class="string">&quot;                  State = &quot;</span> + QString::number(it.value()[<span class="number">0</span>]) + <span class="string">&quot;;\r\n&quot;</span>;</span><br><span class="line">				Res += <span class="string">&quot;                  break;\r\n&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; Definitions_char[temp].size(); j++) &#123;</span><br><span class="line">					Res += <span class="string">&quot;              case &#x27;&quot;</span>;</span><br><span class="line">					Res += Definitions_char[temp][j];</span><br><span class="line">					Res += <span class="string">&quot;&#x27; :\r\n&quot;</span>;</span><br><span class="line">					Res += <span class="string">&quot;                  State = &quot;</span> + QString::number(it.value()[<span class="number">0</span>]) + <span class="string">&quot;;\r\n&quot;</span>;</span><br><span class="line">					Res += <span class="string">&quot;                  break;\r\n&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Res += <span class="string">&quot;              default:\r\n&quot;</span>;</span><br><span class="line">		<span class="comment">//if (MinDFA_End_Point.contains(i)) </span></span><br><span class="line">		Res += <span class="string">&quot;                  State = &quot;</span> + QString::number(MinDFA_Points_num + <span class="number">1</span>) + <span class="string">&quot;;\r\n&quot;</span>;<span class="comment">//接收到了不包含在Char_set中的字符。</span></span><br><span class="line">		<span class="comment">//else</span></span><br><span class="line">			<span class="comment">//Res += &quot;                  State = &quot; + QString::number(i) + &quot;;\r\n&quot;;</span></span><br><span class="line">		Res += <span class="string">&quot;                  break;\r\n&quot;</span>;</span><br><span class="line">		<span class="comment">//if (!G_Min_DFA[i].isEmpty())后面改</span></span><br><span class="line">		Res += <span class="string">&quot;              &#125;\r\n&quot;</span>;</span><br><span class="line">		Res += <span class="string">&quot;              break;\r\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Res += <span class="string">&quot;          &#125;\r\n&quot;</span>;</span><br><span class="line">	Res += <span class="string">&quot;     pos++;\r\n&quot;</span>;</span><br><span class="line">	Res += <span class="string">&quot;     &#125;\r\n&quot;</span>;</span><br><span class="line">	Res += <span class="string">&quot;     if (&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MinDFA_End_Point.size(); i++) &#123;</span><br><span class="line">		Res += <span class="string">&quot;State == &quot;</span>;</span><br><span class="line">		Res += QString::number(MinDFA_End_Point[i]);</span><br><span class="line">		<span class="keyword">if</span> (i != MinDFA_End_Point.size() - <span class="number">1</span>)</span><br><span class="line">			Res += <span class="string">&quot; || &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Res += <span class="string">&quot;)\r\n&quot;</span>;</span><br><span class="line">	Res += <span class="string">&quot;         return true;\r\n&quot;</span>;</span><br><span class="line">	Res += <span class="string">&quot;     else\r\n&quot;</span>;</span><br><span class="line">	Res += <span class="string">&quot;         return false;\r\n&quot;</span>;</span><br><span class="line">	Res += <span class="string">&quot;&#125;\r\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可视化输出部分">可视化输出部分</h3>
<h4 id="思路-5">思路</h4>
<p>这个模块的功能主要是在QT界面上以表格的形式可视化输出生成的 NFA、DFA
和最小化DFA，利用HTML表格的格式来展示每一个状态及其转移关系，将函数返回的字符串直接输出在QT的QTextEdit组件中即可得到表格。下面是代码的思路：</p>
<p><strong>1.输入参数和初始化</strong></p>
<p>据 <code>choice</code> 参数，确定要输出的状态转移表。</p>
<ul>
<li><p>如果 <code>choice</code> 是 1，设置
<code>temp_map = G_NFA_change</code>，表示使用 NFA
的状态转移图，并设置点数为 <code>Points_num</code>。</p></li>
<li><p>如果 <code>choice</code> 是 2，使用 DFA 的状态转移图
<code>G_DFA</code>，点数为 <code>DFA_Points_num</code>。</p></li>
<li><p>如果 <code>choice</code> 是 3，使用最小化 DFA 的状态转移图
<code>G_Min_DFA</code>，点数为 <code>MinDFA_Points_num</code>。</p></li>
</ul>
<p><strong>2.HTML 表格初始化</strong></p>
<p>使用 HTML 标签生成表格的头部结构。<code>Res</code> 用于保存表格的
HTML 代码，开始添加表格 <code>&lt;table&gt;</code>
的样式属性，如边框、填充等。</p>
<p><strong>3.字符集标头</strong></p>
<ul>
<li><p>遍历 <code>Char_set</code>，为每个输入字符创建表格的列标题
(<code>&lt;td&gt;</code> 标签)。</p></li>
<li><p>如果字符是 epsilon (<code>$epsilon$</code>)，在 NFA
之外的图中不显示 epsilon，因为 DFA 和最小化 DFA 中不会有 epsilon
转移。</p></li>
<li><p>为了确保表格在 HTML 中显示正确，将 <code>$</code> 符号去掉，并将
<code>&lt;</code> 替换为 <code>&amp;lt;</code>，以避免 HTML
标签解析的冲突。</p></li>
</ul>
<p><strong>3.epsilon 的处理</strong></p>
<p>对于 NFA 输出 (<code>choice</code> 为 1)，需要加入 epsilon
转移，因此将 <code>$epsilon$</code> 添加到 <code>Char_set</code>
中。对于其他情况，移除 epsilon。</p>
<p><strong>4.遍历状态</strong></p>
<p>对于每个状态 <code>i</code>，创建一个新行 (<code>&lt;tr&gt;</code>
标签)。如果状态 <code>i</code>
是图像的起始状态和终态进行特殊标记，以方便用户识别不同类型的状态，其余状态保持默认颜色：</p>
<ul>
<li><p>起始状态：用浅蓝色背景 (<code>bgcolor='lightblue'</code>)
标记。</p></li>
<li><p>终止状态：用浅绿色背景 (<code>bgcolor='lightgreen'</code>)
标记。</p></li>
</ul>
<p><strong>5.生成状态转移信息</strong></p>
<p>对于每个字符 <code>Char_set[j]</code>，生成状态 <code>i</code>
在输入字符 <code>Char_set[j]</code>
后的转移。使用嵌套循环，遍历每个字符的转移集合
<code>temp_map[i][Char_set[j]]</code>，将所有可能的状态列出（如果有多个状态，用中文逗号分隔）。</p>
<p><strong>6.生成 HTML 表格尾部</strong></p>
<p>通过 <code>&lt;table&gt;</code> 标签结束符关闭表格，最终返回
<code>Res</code>，它包含了完整的 HTML 代码。</p>
<h4 id="代码-5">代码</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">QString <span class="title function_">Graph::Display</span><span class="params">(<span class="type">int</span> choice)</span></span><br><span class="line">&#123;</span><br><span class="line">	QMap&lt;<span class="type">int</span>, QMap&lt;QString, QVector&lt;<span class="type">int</span>&gt;&gt;&gt;temp_map;</span><br><span class="line">	<span class="type">int</span> temp_point_num = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//根据参数来输出不同的表格，1输出NFA，2输出DFA，3输出min_DFA</span></span><br><span class="line">	<span class="keyword">if</span> (choice == <span class="number">1</span>)</span><br><span class="line">		temp_map = G_NFA_change, temp_point_num = Points_num;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">2</span>)</span><br><span class="line">		temp_map = G_DFA, temp_point_num = DFA_Points_num;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">3</span>)</span><br><span class="line">		temp_map = G_Min_DFA, temp_point_num = MinDFA_Points_num;</span><br><span class="line">	QString Res; Res.clear();</span><br><span class="line">	Res = <span class="string">&quot;&lt;table border=&#x27;1&#x27; cellpadding=&#x27;5&#x27;&gt; &quot;</span><span class="string">&quot; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Char_set.size(); i++) &#123;</span><br><span class="line">		QString temp_name = Char_set[i];</span><br><span class="line">		<span class="keyword">if</span> (Char_set[i] == <span class="string">&quot;$epsilon$&quot;</span> &amp;&amp; choice != <span class="number">1</span>)<span class="comment">//后面加的，为了在DFA的图中不显示epsilon</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//因为在HTML中&#x27;&lt;&#x27;是特殊字符，用于表示标签的开始。直接将 &lt; 作为普通字符输出时，浏览器会试图解析它为标签，导致显示混乱或错误。</span></span><br><span class="line">		Res += <span class="string">&quot;&lt;td&gt; &quot;</span> + temp_name.remove(<span class="string">&#x27;$&#x27;</span>).remove(<span class="string">&#x27;\\&#x27;</span>).replace(<span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&amp;lt;&quot;</span>) + <span class="string">&quot;&lt;/td&gt;&quot;</span>;<span class="comment">//(后面改过关于小于号的)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (choice == <span class="number">1</span> &amp;&amp; Char_set.indexOf(<span class="string">&quot;$epsilon$&quot;</span>) == <span class="number">-1</span>)</span><br><span class="line">		Res += <span class="string">&quot;&lt;td&gt;epsilon &lt;/td&gt;&quot;</span>, Char_set.append(<span class="string">&quot;$epsilon$&quot;</span>);<span class="comment">//NFA中需要有$epsilon$</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (choice != <span class="number">1</span>)</span><br><span class="line">		Char_set.removeOne(<span class="string">&quot;$epsilon$&quot;</span>);<span class="comment">//移除掉epsilon,后面加的</span></span><br><span class="line"></span><br><span class="line">	Res += <span class="string">&quot;&lt;/tr&gt;&quot;</span>; <span class="comment">//表格换行</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= temp_point_num; i++) &#123;</span><br><span class="line">		Res += <span class="string">&quot;&lt;tr&gt;&quot;</span>;<span class="comment">//表格开始一行</span></span><br><span class="line">		<span class="comment">//起始点标记</span></span><br><span class="line">		<span class="keyword">if</span> ((choice == <span class="number">1</span> &amp;&amp; i == Begin_Point) || (choice == <span class="number">2</span> &amp;&amp; i == DFA_Begin_Point) || (choice == <span class="number">3</span> &amp;&amp; i == MinDFA_Begin_Point))</span><br><span class="line">			Res += <span class="string">&quot;&lt;td bgcolor=&#x27;lightblue&#x27;&gt;&quot;</span> + QString::number(i) + <span class="string">&quot;&lt;/td&gt;&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((choice == <span class="number">1</span> &amp;&amp; End_Point == i) || (choice == <span class="number">2</span> &amp;&amp; DFA_End_Point.indexOf(i) != <span class="number">-1</span>) || (choice == <span class="number">3</span> &amp;&amp; MinDFA_End_Point.indexOf(i) != <span class="number">-1</span>))</span><br><span class="line">			Res += <span class="string">&quot;&lt;td bgcolor=&#x27;lightgreen&#x27;&gt;&quot;</span> + QString::number(i) + <span class="string">&quot;&lt;/td&gt;&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			Res += <span class="string">&quot;&lt;td&gt;&quot;</span> + QString::number(i) + <span class="string">&quot;&lt;/td&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; Char_set.size(); j++) &#123;</span><br><span class="line">			Res += <span class="string">&quot;&lt;td&gt;&quot;</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; temp_map[i][Char_set[j]].size(); k++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (k == <span class="number">0</span>) Res += QString::number(temp_map[i][Char_set[j]][k]);</span><br><span class="line">				<span class="keyword">else</span> Res += <span class="string">&quot;，&quot;</span> + QString::number(temp_map[i][Char_set[j]][k]);</span><br><span class="line">			&#125;</span><br><span class="line">			Res += <span class="string">&quot;&lt;/td&gt;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Res += <span class="string">&quot;&lt;/tr&gt;&quot;</span>;<span class="comment">//表格换行</span></span><br><span class="line">	&#125;</span><br><span class="line">	Res += <span class="string">&quot;&lt;/table&gt;&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注">注</h2>
<p><strong>1、</strong>
在生成NFA部分中，存储NFA的数据结构是<code>QMap&lt;int, QMap&lt;int, QString&gt;&gt;G</code>
，因为一开始的时候想的是像以前一样使用二维数组的方式来存储图，但是开始写生成DFA部分的时候，发现<code>QMap&lt;int, QMap&lt;QString, QVector&lt;int&gt;&gt;&gt;G_NFA_change</code>的结构可以让后面的算法变得好写一点，然后就在<code>GenerateNFA()</code>运算结束的时候转换了一下数据结构（其实也可以再把前面的写的代码中NFA的数据结构改了，但是我太懒了，就没改）。</p>
<p><strong>2、</strong>浴帘老师要求如果正则表达式得名字后面有数字的话，就把这个数字当成类似实验一中得<code>TokenID</code>，所以预处理里面我也处理了一下，但是我在整个实验中实在是没有用到这个东西，问了问其他同学，其他同学也不是很明白老师的意思，那就这样吧。</p>
<p><strong>3、</strong>通过使用多个<code>Graph</code>类的对象，我们可以一次处理多个正则表达式，但是这个时候程序可能需要稍等一秒钟才可以输出结果。</p>
<p><strong>4、</strong>NFA转的DFA的输出是输出的点对应的状态集合？（代码中输出的是DFA中的点，如果想要输出DFA中点对应的NFA的点的集合的话，就在Display()函数中特殊处理一下choice==2的情况）。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://lemonade-for-hard-thinking.github.io">铁柱帅哥</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://lemonade-for-hard-thinking.github.io/2024/10/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%BA%8C/">https://lemonade-for-hard-thinking.github.io/2024/10/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%BA%8C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/background.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/09/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%80/" title="编译原理实验一"><img class="cover" src="/img/background.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next</div><div class="next_info">编译原理实验一</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="toc-number">1.</span> <span class="toc-text">实验内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4%E5%8F%8A%E4%BB%A3%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">实验步骤及代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">2.1.</span> <span class="toc-text">实验所使用的类和函数的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E9%83%A8%E5%88%86"><span class="toc-number">2.2.</span> <span class="toc-text">预处理部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">2.2.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90nfa%E9%83%A8%E5%88%86"><span class="toc-number">2.3.</span> <span class="toc-text">生成NFA部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">2.3.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90dfa%E9%83%A8%E5%88%86"><span class="toc-number">2.4.</span> <span class="toc-text">生成DFA部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">2.4.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-number">2.4.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%8C%96dfa%E9%83%A8%E5%88%86"><span class="toc-number">2.5.</span> <span class="toc-text">最小化DFA部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-number">2.5.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-number">2.5.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E9%83%A8%E5%88%86"><span class="toc-number">2.6.</span> <span class="toc-text">生成词法分析程序部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-number">2.6.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-number">2.6.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E8%BE%93%E5%87%BA%E9%83%A8%E5%88%86"><span class="toc-number">2.7.</span> <span class="toc-text">可视化输出部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-number">2.7.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-number">2.7.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8"><span class="toc-number">3.</span> <span class="toc-text">注</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 铁柱帅哥</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>